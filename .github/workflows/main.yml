name: Test Sparkle Release (Safe)

on:
  workflow_dispatch:
    inputs:
      source_repo:
        description: 'Source repository to clone (e.g., ejbills/DockDoor)'
        required: true
        default: 'ejbills/DockDoor'
        type: string
      source_branch:
        description: 'Branch to clone from source repo'
        required: true
        default: 'main'
        type: string
      version_increment:
        description: 'Version increment type (TEST ONLY - no actual release)'
        required: true
        default: 'patch'
        type: choice
        options:
        - major
        - minor
        - patch
      release_notes:
        description: 'Test release notes'
        required: false
        type: string
        default: 'TEST RELEASE - This is a test run of the automation'

jobs:
  test-release:
    runs-on: macos-latest
    
    steps:
    - name: ‚ö†Ô∏è TEST MODE WARNING
      run: |
        echo "üß™ THIS IS A TEST RUN - NO ACTUAL RELEASE WILL BE CREATED"
        echo "üìã This workflow will:"
        echo "   ‚úÖ Test version calculation"
        echo "   ‚úÖ Test project file parsing"
        echo "   ‚úÖ Test build process (dry run)"
        echo "   ‚úÖ Test appcast generation"
        echo "   ‚ùå Will NOT create GitHub release"
        echo "   ‚ùå Will NOT push changes to repository"
        echo "   ‚ùå Will NOT upload any assets"
        echo ""
    
    - name: Clone source repository
      run: |
        echo "üîÑ Cloning ${{ github.event.inputs.source_repo }}..."
        git clone https://github.com/${{ github.event.inputs.source_repo }}.git source-repo
        cd source-repo
        git checkout ${{ github.event.inputs.source_branch }}
        echo "‚úÖ Cloned ${{ github.event.inputs.source_repo }}:${{ github.event.inputs.source_branch }}"
        
        # Move contents to workspace root
        cd ..
        cp -R source-repo/* .
        cp -R source-repo/.* . 2>/dev/null || true
        rm -rf source-repo
        
        echo "üìÅ Repository contents:"
        ls -la
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Install Apple Intermediate Certificates
      run: |
        echo "üîß Installing Apple Worldwide Developer Relations Certification Authority..."
        
        # Download and install Apple WWDR CA certificate (original)
        curl -o AppleWWDRCA.cer https://developer.apple.com/certificationauthority/AppleWWDRCA.cer
        sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain AppleWWDRCA.cer
        
        # Also install the newer G3 certificate
        curl -o AppleWWDRCAG3.cer https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer
        sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain AppleWWDRCAG3.cer
        
        # Install Developer ID CA certificate for distribution signing
        curl -o DeveloperIDCA.cer https://www.apple.com/certificateauthority/DeveloperIDCA.cer
        sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain DeveloperIDCA.cer
        
        # Clean up
        rm -f AppleWWDRCA.cer AppleWWDRCAG3.cer DeveloperIDCA.cer
        
        echo "‚úÖ Apple intermediate certificates installed"
    
    - name: Import Code Signing Certificates
      uses: apple-actions/import-codesign-certs@v3
      with:
        p12-file-base64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        p12-password: ${{ secrets.P12_PASSWORD }}
        keychain: signing_temp_${{ github.run_id }}
        keychain-password: ${{ github.run_id }}
    
    - name: Setup Certificate for Build
      run: |
        echo "üîç Setting up certificate for build..."
        
        # Check the keychain that the Apple Action created
        KEYCHAIN_PATH="/Users/runner/Library/Keychains/signing_temp_${{ github.run_id }}.keychain-db"
        
        # Unlock the keychain
        security unlock-keychain -p "${{ github.run_id }}" "$KEYCHAIN_PATH"
        
        # Set it as the default keychain
        security default-keychain -s "$KEYCHAIN_PATH"
        
        # Try to extract any certificate name from keychain
        CERT_NAME=$(security dump-keychain "$KEYCHAIN_PATH" | grep 'labl' | sed 's/.*"labl"<blob>="\(.*\)"/\1/' | head -1)
        
        if [ -z "$CERT_NAME" ]; then
          echo "‚ö†Ô∏è Could not extract certificate name, will try automatic signing"
          echo "SIGNING_CERTIFICATE=" >> $GITHUB_ENV
        else
          echo "üìã Found certificate: $CERT_NAME"
          echo "SIGNING_CERTIFICATE=$CERT_NAME" >> $GITHUB_ENV
        fi
    
    - name: Get current version
      id: current_version
      run: |
        CURRENT_VERSION=$(grep -o 'MARKETING_VERSION = [0-9.]*' DockDoor.xcodeproj/project.pbxproj | head -1 | cut -d' ' -f3 | tr -d ';')
        echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "‚úÖ Current version detected: $CURRENT_VERSION"
    
    - name: Calculate new version (TEST)
      id: new_version  
      run: |
        CURRENT="${{ steps.current_version.outputs.current }}"
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]}
        
        case "${{ github.event.inputs.version_increment }}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "‚úÖ Would increment to: $NEW_VERSION"
        echo "üìä Version change: $CURRENT ‚Üí $NEW_VERSION (${{ github.event.inputs.version_increment }})"
    
    - name: Test version update (dry run)
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new }}"
        echo "üîç Testing version update process..."
        
        # Create backup of project file
        cp DockDoor.xcodeproj/project.pbxproj DockDoor.xcodeproj/project.pbxproj.backup
        
        # Test the sed commands
        sed -i '' "s/MARKETING_VERSION = [0-9.]*/MARKETING_VERSION = $NEW_VERSION/g" DockDoor.xcodeproj/project.pbxproj
        sed -i '' "s/CURRENT_PROJECT_VERSION = [0-9.]*/CURRENT_PROJECT_VERSION = $NEW_VERSION/g" DockDoor.xcodeproj/project.pbxproj
        
        # Verify changes
        echo "‚úÖ Version replacement test successful:"
        grep "MARKETING_VERSION = " DockDoor.xcodeproj/project.pbxproj | head -2
        grep "CURRENT_PROJECT_VERSION = " DockDoor.xcodeproj/project.pbxproj | head -2
        
        # Restore original file
        mv DockDoor.xcodeproj/project.pbxproj.backup DockDoor.xcodeproj/project.pbxproj
        echo "‚úÖ Original project file restored"
    
    - name: Build and Create DMG
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        echo "üî® Building app and creating DMG..."
        
        # Clean build folder
        rm -rf build/
        
        # Create ExportOptions.plist - try automatic signing first
        if [ -n "$SIGNING_CERTIFICATE" ]; then
          echo "üîß Using manual signing with certificate: $SIGNING_CERTIFICATE"
          
          if echo "$SIGNING_CERTIFICATE" | grep -q "Developer ID Application"; then
            EXPORT_METHOD="developer-id"
          else
            EXPORT_METHOD="development"
          fi
          
          cat > ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>$EXPORT_METHOD</string>
            <key>teamID</key>
            <string>$APPLE_TEAM_ID</string>
            <key>uploadBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
            <key>compileBitcode</key>
            <false/>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>$SIGNING_CERTIFICATE</string>
            <key>stripSwiftSymbols</key>
            <true/>
        </dict>
        </plist>
        EOF
        else
          echo "üîß Using automatic signing"
          
          cat > ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>development</string>
            <key>teamID</key>
            <string>$APPLE_TEAM_ID</string>
            <key>uploadBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
            <key>compileBitcode</key>
            <false/>
            <key>signingStyle</key>
            <string>automatic</string>
            <key>stripSwiftSymbols</key>
            <true/>
        </dict>
        </plist>
        EOF
        fi
        
        # Build for release
        xcodebuild -project DockDoor.xcodeproj \
          -scheme DockDoor \
          -configuration Release \
          -derivedDataPath build/ \
          -archivePath build/DockDoor.xcarchive \
          archive
        
        # Export the app
        xcodebuild -exportArchive \
          -archivePath build/DockDoor.xcarchive \
          -exportPath build/export \
          -exportOptionsPlist ExportOptions.plist
        
        # Create proper DMG with Applications shortcut
        APP_PATH="build/export/DockDoor.app"
        DMG_PATH="build/DockDoor.dmg"
        TEMP_DMG_DIR="build/dmg_temp"
        
        if [ -d "$APP_PATH" ]; then
          # Create temporary directory for DMG contents
          mkdir -p "$TEMP_DMG_DIR"
          
          # Copy app to temp directory
          cp -R "$APP_PATH" "$TEMP_DMG_DIR/"
          
          # Create symbolic link to Applications
          ln -s /Applications "$TEMP_DMG_DIR/Applications"
          
          # Create DMG with proper drag-and-drop layout
          hdiutil create -volname "DockDoor" -srcfolder "$TEMP_DMG_DIR" -ov -format UDZO "$DMG_PATH"
          
          # Clean up temp directory
          rm -rf "$TEMP_DMG_DIR"
          
          echo "‚úÖ DMG created at $DMG_PATH with Applications shortcut"
          
          # Show DMG info
          DMG_SIZE=$(stat -f%z "$DMG_PATH")
          echo "üì¶ DMG Size: $DMG_SIZE bytes"
          ls -lah "$DMG_PATH"
        else
          echo "‚ùå Error: App not found at $APP_PATH"
          exit 1
        fi
    
    - name: Upload DMG as Artifact
      uses: actions/upload-artifact@v4
      with:
        name: DockDoor-Test-v${{ steps.new_version.outputs.new }}
        path: build/DockDoor.dmg
        retention-days: 7
    
    - name: Generate and Display Appcast
      env:
        SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
      run: |
        echo "üì° Generating actual appcast with real DMG..."
        
        NEW_VERSION="${{ steps.new_version.outputs.new }}"
        DMG_SIZE=$(stat -f%z build/DockDoor.dmg)
        DOWNLOAD_URL="https://github.com/ejbills/DockDoor/releases/latest/download/DockDoor.dmg"
        
        echo "üìä DMG Info:"
        echo "  Version: $NEW_VERSION"
        echo "  Size: $DMG_SIZE bytes"
        echo "  Download URL: $DOWNLOAD_URL"
        echo ""
        
        # Generate appcast with proper signatures using Sparkle's tool
        if [ -n "$SPARKLE_PRIVATE_KEY" ]; then
          echo "üîê Generating SIGNED appcast with Sparkle tool..."
          
          # Create a temporary directory for appcast generation
          mkdir -p temp_appcast
          cp build/DockDoor.dmg "temp_appcast/DockDoor-$NEW_VERSION.dmg"
          
          # Save private key to temporary file
          echo "$SPARKLE_PRIVATE_KEY" > temp_private_key.pem
          
          # Generate appcast with signatures
          ./Sparkle/generate_appcast \
            --ed-key-file temp_private_key.pem \
            --download-url-prefix "https://github.com/ejbills/DockDoor/releases/latest/download/" \
            --release-notes-url-prefix "https://dockdoor.net/CHANGELOG.html" \
            temp_appcast/
          
          echo "‚úÖ SIGNED Appcast generated:"
          echo "=========================="
          cat temp_appcast/appcast.xml
          echo "=========================="
          
          # Clean up
          rm -f temp_private_key.pem
          rm -rf temp_appcast
        else
          echo "‚ö†Ô∏è Generating UNSIGNED appcast (SPARKLE_PRIVATE_KEY not set)..."
          CURRENT_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
          
          echo "‚úÖ UNSIGNED Appcast would be:"
          echo "=========================="
          cat << 'EOF'
        <?xml version="1.0" standalone="yes"?>
        <rss xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" version="2.0">
            <channel>
                <title>DockDoor</title>
                <item>
                    <title>$NEW_VERSION</title>
                    <pubDate>$CURRENT_DATE</pubDate>
                    <sparkle:releaseNotesLink>https://dockdoor.net/CHANGELOG.html</sparkle:releaseNotesLink>
                    <sparkle:version>$NEW_VERSION</sparkle:version>
                    <sparkle:shortVersionString>$NEW_VERSION</sparkle:shortVersionString>
                    <sparkle:minimumSystemVersion>13.0</sparkle:minimumSystemVersion>
                    <enclosure url="$DOWNLOAD_URL" length="$DMG_SIZE" type="application/octet-stream"/>
                </item>
            </channel>
        </rss>
        EOF
          echo "=========================="
        fi
    
    - name: Test Sparkle signing (if configured)
      run: |
        if [ -n "${{ secrets.SPARKLE_PRIVATE_KEY }}" ]; then
          echo "‚úÖ SPARKLE_PRIVATE_KEY secret is configured"
          echo "üîê Sparkle signing would be enabled in real release"
        else
          echo "‚ö†Ô∏è  SPARKLE_PRIVATE_KEY secret not configured"
          echo "üìù Appcast would be generated without signatures"
        fi
        
        if [ -n "${{ secrets.APPLE_TEAM_ID }}" ]; then
          echo "‚úÖ APPLE_TEAM_ID secret is configured"
        else
          echo "‚ö†Ô∏è  APPLE_TEAM_ID secret not configured"
        fi
    
    - name: Test release notes generation
      run: |
        echo "üìù Testing release notes generation..."
        
        if [ -n "${{ github.event.inputs.release_notes }}" ]; then
          echo "‚úÖ Using provided release notes:"
          echo "${{ github.event.inputs.release_notes }}"
        else
          echo "üìÑ Would extract from CHANGELOG.md:"
          if [ -f "CHANGELOG.md" ]; then
            echo "‚úÖ CHANGELOG.md found"
            # Show what would be extracted
            awk '/^## \[/ {if(found) exit; found=1; next} found && /^## \[/ {exit} found {print}' CHANGELOG.md | head -10
          else
            echo "‚ö†Ô∏è  CHANGELOG.md not found, would use default notes"
          fi
        fi
    
    - name: üéâ Test Summary
      run: |
        echo "üß™ TEST COMPLETE - Summary:"
        echo "================================="
        echo "Current Version: ${{ steps.current_version.outputs.current }}"
        echo "Would Create: v${{ steps.new_version.outputs.new }}"
        echo "Increment Type: ${{ github.event.inputs.version_increment }}"
        echo "Branch: ${{ github.ref_name }}"
        echo ""
        echo "‚úÖ Version calculation: PASSED"
        echo "‚úÖ Project file updates: PASSED" 
        echo "‚úÖ Build configuration: PASSED"
        echo "‚úÖ Appcast generation: PASSED"
        echo ""
        echo "üöÄ Ready for real release? Run 'Sparkle Release Automation' workflow"
        echo "‚ö†Ô∏è  Remember to merge this branch to main first if testing on a feature branch"
    

