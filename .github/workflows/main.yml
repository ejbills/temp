name: Test Sparkle Release (Safe)

on:
  workflow_dispatch:
    inputs:
      source_repo:
        description: 'Source repository to clone (e.g., ejbills/DockDoor)'
        required: true
        default: 'ejbills/DockDoor'
        type: string
      source_branch:
        description: 'Branch to clone from source repo'
        required: true
        default: 'main'
        type: string
      version_increment:
        description: 'Version increment type (TEST ONLY - no actual release)'
        required: true
        default: 'patch'
        type: choice
        options:
        - major
        - minor
        - patch
      release_notes:
        description: 'Test release notes'
        required: false
        type: string
        default: 'TEST RELEASE - This is a test run of the automation'

jobs:
  test-release:
    runs-on: macos-latest
    
    steps:
    - name: ⚠️ TEST MODE WARNING
      run: |
        echo "🧪 THIS IS A TEST RUN - NO ACTUAL RELEASE WILL BE CREATED"
        echo "📋 This workflow will:"
        echo "   ✅ Test version calculation"
        echo "   ✅ Test project file parsing"
        echo "   ✅ Test build process (dry run)"
        echo "   ✅ Test appcast generation"
        echo "   ❌ Will NOT create GitHub release"
        echo "   ❌ Will NOT push changes to repository"
        echo "   ❌ Will NOT upload any assets"
        echo ""
    
    - name: Clone source repository
      run: |
        echo "🔄 Cloning ${{ github.event.inputs.source_repo }}..."
        git clone https://github.com/${{ github.event.inputs.source_repo }}.git source-repo
        cd source-repo
        git checkout ${{ github.event.inputs.source_branch }}
        echo "✅ Cloned ${{ github.event.inputs.source_repo }}:${{ github.event.inputs.source_branch }}"
        
        # Move contents to workspace root
        cd ..
        cp -R source-repo/* .
        cp -R source-repo/.* . 2>/dev/null || true
        rm -rf source-repo
        
        echo "📁 Repository contents:"
        ls -la
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Setup signing certificates
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create variables for keychain and certificate paths
        CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        
        # Import certificate from secrets
        echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
        
        # Verify certificate file was created
        if [ ! -f "$CERTIFICATE_PATH" ]; then
          echo "❌ Certificate file not created"
          exit 1
        fi
        
        echo "✅ Certificate file created: $(ls -lh $CERTIFICATE_PATH)"
        
        # Verify it's a valid P12 file
        file $CERTIFICATE_PATH
        
        # Create temporary keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        
        # Import certificate to keychain (import all items, not just cert)
        echo "🔄 Importing certificate..."
        security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -f pkcs12 -k $KEYCHAIN_PATH
        
        # Set the keychain search list
        security list-keychain -d user -s $KEYCHAIN_PATH
        
        # Check if import was successful
        echo "✅ Certificate import completed"
        
        # Debug: Check what's actually in the keychain
        echo "🔍 All items in keychain:"
        security dump-keychain $KEYCHAIN_PATH | grep -E "(keychain|labl|Developer ID)" || echo "No items found"
        
        echo "🔍 All identities (not just codesigning):"
        security find-identity -v $KEYCHAIN_PATH
        
        # Find the actual certificate name
        echo "🔍 Available code signing certificates:"
        security find-identity -v -p codesigning $KEYCHAIN_PATH
        
        # Get the Developer ID Application certificate name
        CERT_LINE=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Developer ID Application" | head -1)
        
        if [ -z "$CERT_LINE" ]; then
          echo "❌ No Developer ID Application certificate found"
          echo "Available certificates:"
          security find-identity -v $KEYCHAIN_PATH
          exit 1
        fi
        
        CERT_NAME=$(echo "$CERT_LINE" | sed 's/.*) "\(.*\)"/\1/')
        echo "📋 Using certificate: $CERT_NAME"
        echo "SIGNING_CERTIFICATE=$CERT_NAME" >> $GITHUB_ENV
        
        # Verify the certificate is valid for code signing
        security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "$CERT_NAME" || {
          echo "❌ Certificate not valid for code signing"
          exit 1
        }
        
        # Clean up
        rm $CERTIFICATE_PATH
    
    - name: Get current version
      id: current_version
      run: |
        CURRENT_VERSION=$(grep -o 'MARKETING_VERSION = [0-9.]*' DockDoor.xcodeproj/project.pbxproj | head -1 | cut -d' ' -f3 | tr -d ';')
        echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "✅ Current version detected: $CURRENT_VERSION"
    
    - name: Calculate new version (TEST)
      id: new_version  
      run: |
        CURRENT="${{ steps.current_version.outputs.current }}"
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]}
        
        case "${{ github.event.inputs.version_increment }}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "✅ Would increment to: $NEW_VERSION"
        echo "📊 Version change: $CURRENT → $NEW_VERSION (${{ github.event.inputs.version_increment }})"
    
    - name: Test version update (dry run)
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new }}"
        echo "🔍 Testing version update process..."
        
        # Create backup of project file
        cp DockDoor.xcodeproj/project.pbxproj DockDoor.xcodeproj/project.pbxproj.backup
        
        # Test the sed commands
        sed -i '' "s/MARKETING_VERSION = [0-9.]*/MARKETING_VERSION = $NEW_VERSION/g" DockDoor.xcodeproj/project.pbxproj
        sed -i '' "s/CURRENT_PROJECT_VERSION = [0-9.]*/CURRENT_PROJECT_VERSION = $NEW_VERSION/g" DockDoor.xcodeproj/project.pbxproj
        
        # Verify changes
        echo "✅ Version replacement test successful:"
        grep "MARKETING_VERSION = " DockDoor.xcodeproj/project.pbxproj | head -2
        grep "CURRENT_PROJECT_VERSION = " DockDoor.xcodeproj/project.pbxproj | head -2
        
        # Restore original file
        mv DockDoor.xcodeproj/project.pbxproj.backup DockDoor.xcodeproj/project.pbxproj
        echo "✅ Original project file restored"
    
    - name: Build and Create DMG
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        echo "🔨 Building app and creating DMG..."
        
        # Clean build folder
        rm -rf build/
        
        # Create ExportOptions.plist with actual team ID and detected certificate
        cat > ExportOptions.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>developer-id</string>
            <key>teamID</key>
            <string>$APPLE_TEAM_ID</string>
            <key>uploadBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
            <key>compileBitcode</key>
            <false/>
            <key>signingStyle</key>
            <string>manual</string>
            <key>signingCertificate</key>
            <string>$SIGNING_CERTIFICATE</string>
            <key>stripSwiftSymbols</key>
            <true/>
        </dict>
        </plist>
        EOF
        
        # Build for release
        xcodebuild -project DockDoor.xcodeproj \
          -scheme DockDoor \
          -configuration Release \
          -derivedDataPath build/ \
          -archivePath build/DockDoor.xcarchive \
          archive
        
        # Export the app
        xcodebuild -exportArchive \
          -archivePath build/DockDoor.xcarchive \
          -exportPath build/export \
          -exportOptionsPlist ExportOptions.plist
        
        # Create proper DMG with Applications shortcut
        APP_PATH="build/export/DockDoor.app"
        DMG_PATH="build/DockDoor.dmg"
        TEMP_DMG_DIR="build/dmg_temp"
        
        if [ -d "$APP_PATH" ]; then
          # Create temporary directory for DMG contents
          mkdir -p "$TEMP_DMG_DIR"
          
          # Copy app to temp directory
          cp -R "$APP_PATH" "$TEMP_DMG_DIR/"
          
          # Create symbolic link to Applications
          ln -s /Applications "$TEMP_DMG_DIR/Applications"
          
          # Create DMG with proper drag-and-drop layout
          hdiutil create -volname "DockDoor" -srcfolder "$TEMP_DMG_DIR" -ov -format UDZO "$DMG_PATH"
          
          # Clean up temp directory
          rm -rf "$TEMP_DMG_DIR"
          
          echo "✅ DMG created at $DMG_PATH with Applications shortcut"
          
          # Show DMG info
          DMG_SIZE=$(stat -f%z "$DMG_PATH")
          echo "📦 DMG Size: $DMG_SIZE bytes"
          ls -lah "$DMG_PATH"
        else
          echo "❌ Error: App not found at $APP_PATH"
          exit 1
        fi
    
    - name: Upload DMG as Artifact
      uses: actions/upload-artifact@v4
      with:
        name: DockDoor-Test-v${{ steps.new_version.outputs.new }}
        path: build/DockDoor.dmg
        retention-days: 7
    
    - name: Generate and Display Appcast
      env:
        SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
      run: |
        echo "📡 Generating actual appcast with real DMG..."
        
        NEW_VERSION="${{ steps.new_version.outputs.new }}"
        DMG_SIZE=$(stat -f%z build/DockDoor.dmg)
        DOWNLOAD_URL="https://github.com/ejbills/DockDoor/releases/latest/download/DockDoor.dmg"
        
        echo "📊 DMG Info:"
        echo "  Version: $NEW_VERSION"
        echo "  Size: $DMG_SIZE bytes"
        echo "  Download URL: $DOWNLOAD_URL"
        echo ""
        
        # Generate appcast with proper signatures using Sparkle's tool
        if [ -n "$SPARKLE_PRIVATE_KEY" ]; then
          echo "🔐 Generating SIGNED appcast with Sparkle tool..."
          
          # Create a temporary directory for appcast generation
          mkdir -p temp_appcast
          cp build/DockDoor.dmg "temp_appcast/DockDoor-$NEW_VERSION.dmg"
          
          # Save private key to temporary file
          echo "$SPARKLE_PRIVATE_KEY" > temp_private_key.pem
          
          # Generate appcast with signatures
          ./Sparkle/generate_appcast \
            --ed-key-file temp_private_key.pem \
            --download-url-prefix "https://github.com/ejbills/DockDoor/releases/latest/download/" \
            --release-notes-url-prefix "https://dockdoor.net/CHANGELOG.html" \
            temp_appcast/
          
          echo "✅ SIGNED Appcast generated:"
          echo "=========================="
          cat temp_appcast/appcast.xml
          echo "=========================="
          
          # Clean up
          rm -f temp_private_key.pem
          rm -rf temp_appcast
        else
          echo "⚠️ Generating UNSIGNED appcast (SPARKLE_PRIVATE_KEY not set)..."
          CURRENT_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
          
          echo "✅ UNSIGNED Appcast would be:"
          echo "=========================="
          cat << 'EOF'
        <?xml version="1.0" standalone="yes"?>
        <rss xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" version="2.0">
            <channel>
                <title>DockDoor</title>
                <item>
                    <title>$NEW_VERSION</title>
                    <pubDate>$CURRENT_DATE</pubDate>
                    <sparkle:releaseNotesLink>https://dockdoor.net/CHANGELOG.html</sparkle:releaseNotesLink>
                    <sparkle:version>$NEW_VERSION</sparkle:version>
                    <sparkle:shortVersionString>$NEW_VERSION</sparkle:shortVersionString>
                    <sparkle:minimumSystemVersion>13.0</sparkle:minimumSystemVersion>
                    <enclosure url="$DOWNLOAD_URL" length="$DMG_SIZE" type="application/octet-stream"/>
                </item>
            </channel>
        </rss>
        EOF
          echo "=========================="
        fi
    
    - name: Test Sparkle signing (if configured)
      run: |
        if [ -n "${{ secrets.SPARKLE_PRIVATE_KEY }}" ]; then
          echo "✅ SPARKLE_PRIVATE_KEY secret is configured"
          echo "🔐 Sparkle signing would be enabled in real release"
        else
          echo "⚠️  SPARKLE_PRIVATE_KEY secret not configured"
          echo "📝 Appcast would be generated without signatures"
        fi
        
        if [ -n "${{ secrets.APPLE_TEAM_ID }}" ]; then
          echo "✅ APPLE_TEAM_ID secret is configured"
        else
          echo "⚠️  APPLE_TEAM_ID secret not configured"
        fi
    
    - name: Test release notes generation
      run: |
        echo "📝 Testing release notes generation..."
        
        if [ -n "${{ github.event.inputs.release_notes }}" ]; then
          echo "✅ Using provided release notes:"
          echo "${{ github.event.inputs.release_notes }}"
        else
          echo "📄 Would extract from CHANGELOG.md:"
          if [ -f "CHANGELOG.md" ]; then
            echo "✅ CHANGELOG.md found"
            # Show what would be extracted
            awk '/^## \[/ {if(found) exit; found=1; next} found && /^## \[/ {exit} found {print}' CHANGELOG.md | head -10
          else
            echo "⚠️  CHANGELOG.md not found, would use default notes"
          fi
        fi
    
    - name: 🎉 Test Summary
      run: |
        echo "🧪 TEST COMPLETE - Summary:"
        echo "================================="
        echo "Current Version: ${{ steps.current_version.outputs.current }}"
        echo "Would Create: v${{ steps.new_version.outputs.new }}"
        echo "Increment Type: ${{ github.event.inputs.version_increment }}"
        echo "Branch: ${{ github.ref_name }}"
        echo ""
        echo "✅ Version calculation: PASSED"
        echo "✅ Project file updates: PASSED" 
        echo "✅ Build configuration: PASSED"
        echo "✅ Appcast generation: PASSED"
        echo ""
        echo "🚀 Ready for real release? Run 'Sparkle Release Automation' workflow"
        echo "⚠️  Remember to merge this branch to main first if testing on a feature branch"
    
    - name: Clean up keychain
      if: always()
      run: |
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        if [ -f "$KEYCHAIN_PATH" ]; then
          security delete-keychain $KEYCHAIN_PATH || true
        fi

